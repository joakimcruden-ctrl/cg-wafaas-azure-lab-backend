#cloud-config
package_update: true
packages:
  - nmap
  - sqlmap
  - gobuster
  - ffuf
  - curl
  - httpie
  - jq
  - git
  - docker.io

# Ensure SSH password auth is enabled
ssh_pwauth: true
write_files:
  - path: /etc/ssh/sshd_config.d/60-password-auth.conf
    permissions: '0644'
    content: |
      PasswordAuthentication yes
  - path: /etc/sudoers.d/99-lab-nopasswd
    permissions: '0440'
    content: |
      %sudo ALL=(ALL) NOPASSWD:ALL
  - path: /etc/ssh/sshd_config.d/99-password-override.conf
    permissions: '0644'
    content: |
      PasswordAuthentication yes
      KbdInteractiveAuthentication no
      UsePAM yes
  - path: /usr/local/bin/seed-api-discovery.sh
    permissions: '0755'
    content: |
      #!/usr/bin/env bash
      set -euo pipefail
      
      BASE="$${1:-$${S:-}}"
      if [[ -z "$BASE" ]]; then
        echo "Usage: $0 <base-url>   e.g. $0 https://<sub>.ccsm-e.se"
        exit 1
      fi
      
      # Optional creds for VAmPI (defaults work in the demo image)
      API_USER="$${API_USER:-morty}"
      API_PASS="$${API_PASS:-morty}"
      
      # Tuning knobs
      SAFE_ONLY="$${SAFE_ONLY:-0}"     # 1 = GET only, skip POST/PUT/PATCH
      SLEEP="$${SLEEP:-0}"             # seconds to sleep between requests (e.g., 0.15)
      
      workdir="$(mktemp -d)"
      trap 'rm -rf "$workdir"' EXIT
      
      echo "[*] Base URL: $BASE"
      
      # 1) Try to fetch an OpenAPI/Swagger spec from common endpoints
      schema_url=""
      for c in "/openapi3.yml" "/openapi.yaml" "/openapi.json" "/swagger.json"; do
        if curl -sSf -m 5 "$BASE$c" -o "$workdir/schema.raw" 2>/dev/null; then
          schema_url="$BASE$c"
          break
        fi
      done
      
      if [[ -z "$schema_url" ]]; then
        echo "[!] Could not auto-find an OpenAPI schema at $BASE."
        echo "    Tip: copy it from the container (docker cp ...) and host it temporarily; then re-run."
        exit 2
      fi
      
      echo "[*] Found schema at: $schema_url"
      
      # 2) Normalize to JSON (requires yq if YAML)
      if [[ "$schema_url" == *.yml || "$schema_url" == *.yaml ]]; then
        if ! command -v yq >/dev/null 2>&1; then
          echo "[!] yq is required to convert YAML schema to JSON. Please install yq and re-run."
          exit 3
        fi
        yq -o=json '.' "$workdir/schema.raw" > "$workdir/schema.json"
      else
        # assume JSON already
        cp "$workdir/schema.raw" "$workdir/schema.json"
      fi
      
      # 3) Get an auth token (if login exists); otherwise continue unauthenticated
      TOKEN=""
      if curl -s -m 5 -o /dev/null -w "%%{http_code}" "$BASE/users/v1/login" | grep -qE '200|401|404'; then
        TOKEN="$(curl -s -X POST "$BASE/users/v1/login" \
          -H 'Content-Type: application/json' \
          -d "{\"username\":\"$API_USER\",\"password\":\"$API_PASS\"}" | jq -r '.token // empty' || true)"
      fi
      AUTH=()
      [[ -n "$TOKEN" ]] && AUTH=(-H "Authorization: Bearer $TOKEN")
      
      echo "[*] Using token: $([[ -n "$TOKEN" ]] && echo 'yes' || echo 'no')"
      
      # 4) Iterate paths & methods from the spec
      #    Weâ€™ll do GET/POST/PUT/PATCH. (Skip DELETE by default to avoid destructive ops.)
      paths_and_methods=$(jq -r '
        .paths
        | to_entries[]
        | . as $p
        | ($p.value | keys[] | ascii_downcase)
        | select(IN("get","post","put","patch"))
        | [$p.key, .]
        | @tsv
      ' "$workdir/schema.json")
      
      if [[ -z "$paths_and_methods" ]]; then
        echo "[!] No usable paths/methods found in schema."
        exit 4
      fi
      
      # Helper: fill any {param} with a friendly value
      fill_params() {
        echo "$1" | sed 's/{[^}]*}/seed/g'
      }
      
      # Helper: choose a sample JSON body for POST/PUT/PATCH
      sample_body() {
        local p="$1"
        if [[ "$p" == *"/users/v1/login"* ]]; then
          printf '{"username":"%s","password":"%s"}' "$API_USER" "$API_PASS"
        elif [[ "$p" == *"/users/v1/register"* ]]; then
          printf '{"username":"seed-%s","password":"Lab123!"}' "$RANDOM"
        elif [[ "$p" == *"/books"* ]]; then
          printf '{"title":"Seed","author":"Lab","isbn":"SEED-%s"}' "$RANDOM"
        else
          printf '{"ping":"seed"}'
        fi
      }
      
      echo "[*] Hitting endpoints (this seeds API Discovery on WAF)..."
      logdir="api-seed-$(date +%F-%H%M%S)"
      mkdir -p "$logdir"
      
      ua=(-H 'User-Agent: lab-seeder/1.0' -H 'X-Lab-Seed: true')
      
      while IFS=$'\t' read -r path method; do
        [[ -z "$path" ]] && continue
        m=$(echo "$method" | tr '[:lower:]' '[:upper:]')
        filled=$(fill_params "$path")
        url="$BASE$filled"
      
        # skip mutating methods if SAFE_ONLY=1
        if [[ "$SAFE_ONLY" = "1" && "$m" != "GET" ]]; then
          continue
        fi
      
        if [[ "$m" == "GET" ]]; then
          echo "GET  $url"
          curl -s -o "$logdir/$(echo "$m$filled" | tr '/{} ' '_').body" -w "%%{http_code} %%{time_total}\n" "$${ua[@]}" "$${AUTH[@]}" "$url" \
            | tee "$logdir/$(echo "$m$filled" | tr '/{} ' '_').code" || true
      
        elif [[ "$m" == "POST" || "$m" == "PUT" || "$m" == "PATCH" ]]; then
          data=$(sample_body "$filled")
          echo "$m $url"
          curl -s -o "$logdir/$(echo "$m$filled" | tr '/{} ' '_').body" -w "%%{http_code} %%{time_total}\n" \
            -X "$m" -H 'Content-Type: application/json' "$${ua[@]}" "$${AUTH[@]}" -d "$data" "$url" \
            | tee "$logdir/$(echo "$m$filled" | tr '/{} ' '_').code" || true
        fi
      
        # optional pacing
        if [[ "$SLEEP" != "0" ]]; then
          sleep "$SLEEP"
        fi
      done <<< "$paths_and_methods"
      
      echo "[*] Done. Logs in: $logdir (one .body and one .code per request)"

# Create all attendee users with sudo and no password prompt
users:
  - default
${users_block}

chpasswd:
  list: |
${chpasswd_list}
  expire: false

runcmd:
  - [ systemctl, restart, ssh ]
  - [ systemctl, enable, --now, docker ]
  # Ensure attendee users exist with passwords and sudo before heavy installs
  - |
    bash -lc '
    set -e
    umask 022
    while IFS=':' read -r uname upass; do
      [ -z "$uname" ] && continue
      if ! id -u "$uname" >/dev/null 2>&1; then
        useradd -m -s /bin/bash "$uname"
      fi
      echo "$uname:$upass" | chpasswd || true
      usermod -aG sudo "$uname" || true
      chage -I -1 -m 0 -M 99999 -E -1 "$uname" || true
      install -m 0755 /usr/local/bin/seed-api-discovery.sh "/home/$uname/seed-api-discovery.sh" || true
      chown "$uname:$uname" "/home/$uname/seed-api-discovery.sh" || true
    done <<'EOF_UP_EARLY'
${user_pass_pairs}
EOF_UP_EARLY
    systemctl reload ssh || true
    '
  - |
    bash -lc '
    set -u
    export DEBIAN_FRONTEND=noninteractive
    apt-get update
    apt-get install -y --no-install-recommends software-properties-common apt-transport-https ca-certificates gnupg lsb-release || true
    pkgs="tmux zsh fzf ripgrep fd-find bat jq yq htop btop lsof strace ltrace git python3 python3-pip python3-venv pipx golang-go rustc cargo build-essential cmake nasm mingw-w64 upx-ucl docker.io docker-compose docker-compose-plugin podman neovim curl wget aria2 socat netcat-openbsd openssl nmap theharvester spiderfoot recon-ng rustscan masscan zmap dnsrecon dnsenum nbtscan smbclient enum4linux ldap-utils burpsuite zaproxy mitmproxy ffuf feroxbuster gobuster wfuzz sqlmap nikto wpscan joomscan hashcat john hydra medusa seclists wordlists cewl crunch hashid hashcat-utils python3-impacket responder samba samba-common-bin aircrack-ng hcxdumptool hcxpcapngtool reaver kismet bluez bettercap btlejack gnuradio gqrx-sdr rfcat wireshark tshark tcpdump android-tools-adb android-tools-fastboot apktool jadx ideviceinstaller libimobiledevice-utils ghidra radare2 cutter binwalk binutils file vim-common patchelf gdb lldb afl++ honggfuzz radamsa sleuthkit autopsy bulk-extractor foremost scalpel plaso yara age gnupg hashdeep bsdextrautils rclone openssh-client rsync pandoc"
    for p in $pkgs; do
      if ! apt-cache show "$p" >/dev/null 2>&1; then
        echo "Package $p not found in apt cache; skipping"
        continue
      fi
      apt-get install -y --no-install-recommends "$p" || echo "Failed to install $p; continuing"
    done

    # Secondary install strategies
    # Symlinks for common Debian names
    ln -sf /usr/bin/fdfind /usr/local/bin/fd || true
    ln -sf /usr/bin/batcat /usr/local/bin/bat || true

    # Ensure pipx global installs are available for all users
    if command -v pipx >/dev/null 2>&1; then
      pipx ensurepath || true
      pipx install --global theHarvester || true
      pipx install --global spiderfoot || true
      pipx install --global recon-ng || true
      pipx install --global wfuzz || true
    fi

    # Go-based tools: install latest into /usr/local/bin
    if command -v go >/dev/null 2>&1; then
      export GOBIN=/usr/local/bin
      go install github.com/ffuf/ffuf/v2@latest || true
      go install github.com/OJ/gobuster/v3@latest || true
      go install github.com/bettercap/bettercap@latest || true
    fi

    # Rust-based tools: install and copy binaries into /usr/local/bin
    if command -v cargo >/dev/null 2>&1; then
      cargo install feroxbuster || true
      cargo install rustscan || true
      for bin in /root/.cargo/bin/*; do
        [ -f "$bin" ] && install -m 0755 "$bin" /usr/local/bin/ || true
      done
    fi

    # Place seeder script into each attendee user's home
    while read -r name; do
      [ -z "$name" ] && continue
      if id -u "$name" >/dev/null 2>&1; then
        install -m 0755 /usr/local/bin/seed-api-discovery.sh "/home/$name/seed-api-discovery.sh" || true
        chown "$name:$name" "/home/$name/seed-api-discovery.sh" || true
      fi
    done <<'EOF_USERS'
${usernames_lines}
EOF_USERS

    # Fallback: ensure users exist, set passwords, and add sudo
    while IFS=':' read -r uname upass; do
      [ -z "$uname" ] && continue
      id -u "$uname" >/dev/null 2>&1 || useradd -m -s /bin/bash "$uname"
      echo "$uname:$upass" | chpasswd || true
      usermod -aG sudo "$uname" || true
      chage -I -1 -m 0 -M 99999 -E -1 "$uname" || true
    done <<'EOF_UP'
${user_pass_pairs}
EOF_UP

    # Final ensure sshd picks up overrides after user setup
    systemctl restart ssh || true
    '
